package com.jgarin.base.ui

import android.os.Bundle
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.jgarin.base.ui.entities.BaseEvent
import com.jgarin.base.ui.entities.BaseNavigationScreen
import com.jgarin.base.ui.entities.BaseNavigationWorkflow
import com.jgarin.base.ui.entities.BaseWorkflowState
import com.jgarin.base.wrappers.SingleLiveEvent
import com.jgarin.extensions.distinctUntilChanged
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

/**
 * @param E event type
 * @param WS workflow state type
 * @param NS navigation screen type
 * @param NW workflow navigation type
 */
// I don't like having so many generic type parameters. We need to check if there's a way to reduce it
abstract class BaseViewModel<E : BaseEvent, WS : BaseWorkflowState, NS : BaseNavigationScreen, NW : BaseNavigationWorkflow>(
/*a hook to restore state*/
	savedState: Bundle?
) : ViewModel() {

	// Autogenerated keys to save-restore state from the [Bundle]
	private val screenKey = this::class.java.name + ".Screen"
	private val screenHandledKey = this::class.java.name + ".ScreenHandled"
	private val workflowKey = this::class.java.name + ".Workflow"
	private val workflowHandledKey = this::class.java.name + ".WorkflowHandled"

	/**
	 * Can be replaced with Google's implementation.
	 */
	protected val viewModelScope = CoroutineScope(Dispatchers.Default)

	/**
	 * @param event the event that triggered state change
	 * @param prev previous workflow state
	 * @param screen currently displayed screen
	 * @return new workflow state
	 */
	protected abstract suspend fun reduceState(event: E, prev: WS, screen: NS): WS

	/**
	 * @param event the event that triggered state change
	 * @param prev previous workflow state
	 * @param screen currently displayed screen
	 * @return new screen or null if no navigation is required
	 * */
	protected abstract suspend fun reduceScreen(event: E, prev: WS, screen: NS): NS?

	/**
	 * @param event the event that triggered state change
	 * @param prev previous workflow state
	 * @param screen currently displayed screen
	 * @return new workflow or null if no navigation is required
	 * */
	protected abstract suspend fun reduceWorkflow(event: E, prev: WS, screen: NS): NW?

	/**
	 * Save all the stuff you need to restore later to be in sync with UI.
	 * Things to put here: input field values, selected checkboxes, radio buttons, tabs, etc.
	 * Things NOT to put here: everything that can be fetched from the repository.
	 */
	protected abstract fun saveState(outState: Bundle, state: WS)

	/**
	 * Read previously saved state here or return default state if null.
	 */
	protected abstract fun readState(savedState: Bundle?): WS

	/**
	 * The screen this workflow starts from.
	 */
	protected abstract fun getInitialScreen(): NS

	private val _stateStream = MutableLiveData<WS>()
		.apply { value = readState(savedState) }
	private val _navigationScreen = MutableLiveData<SingleLiveEvent<NS>>()
		.apply { value = readScreen(savedState) }
	private val _navigationWorkflow = MutableLiveData<SingleLiveEvent<NW>>()
		.apply { value = readWorkflow(savedState) }

	/**
	 * Event queue implementation. This helps to get rid of any race conditions and prevent event loss.
	 */
	private val coroutineChannel = Channel<E>()

	/**
	 * Split this into screen states.
	 * Protected visibility restricts direct access.
	 */
	protected val stateStream: LiveData<WS> = _stateStream.distinctUntilChanged()
	/**
	 * You shouldn't subscribe to this. [BaseWorkflowActivity] does its magic for you.
	 */
	val navigationScreen: LiveData<SingleLiveEvent<NS>> = _navigationScreen.distinctUntilChanged()
	/**
	 * You shouldn't subscribe to thiis. [BaseWorkflowActivity] does its magic for you.
	 */
	val navigationWorkflow: LiveData<SingleLiveEvent<NW>> =
		_navigationWorkflow.distinctUntilChanged()

	init {
		viewModelScope.launch(Dispatchers.Unconfined) {
			for (event in coroutineChannel) {
				// I know it throws for nulls, but there're no nulls here unless you make changes to this file.
				val prev = requireNotNull(_stateStream.value)
				val screen = requireNotNull(_navigationScreen.value?.peek())

				// Calculating these in parallel
				val newStateD = async { reduceState(event, prev, screen) }
				val newScreenD = async { reduceScreen(event, prev, screen) }
				val newWorkflowD = async { reduceWorkflow(event, prev, screen) }

				// wait for all calculations to finish
				val newState = newStateD.await()
				val newScreen = newScreenD.await()
				val newWorkflow = newWorkflowD.await()

				// wait for new state to be pushed to respective streams
				withContext(Dispatchers.Main) {
					_stateStream.value = newState
					if (newScreen != null) _navigationScreen.value = SingleLiveEvent(newScreen)
					_navigationWorkflow.value = newWorkflow?.let { SingleLiveEvent(it) }
				}
			}
		}
	}

	/**
	 * Use this to submit events that modify the state of this workflow
	 */
	protected fun submit(event: E) {
		viewModelScope.launch(Dispatchers.Unconfined) { coroutineChannel.send(event) }
	}

	/**
	 * Do not use. [BaseWorkflowActivity] already does it for you.
	 */
	fun onSaveViewModelState(outState: Bundle) {
		val state = stateStream.value ?: return
		val screen = navigationScreen.value ?: return
		val workflow = navigationWorkflow.value
		saveState(outState, state)
		saveScreen(outState, screen)
		saveWorkflow(outState, workflow)
	}

	/**
	 * Override this to submit onBackPressed event to the state machine.
	 */
	abstract fun onBackPressed()

	/**
	 * If you ever override this be sure to call super.onCleared()
	 */
	override fun onCleared() {
		coroutineChannel.close()
		viewModelScope.cancel()
	}

	/**
	 * Saves screen navigation events
	 */
	private fun saveScreen(outState: Bundle, screen: SingleLiveEvent<NS>) {
		outState.putParcelable(screenKey, screen.peek())
		outState.putBoolean(screenHandledKey, screen.isHandled)
	}

	/**
	 * Restores screen navigation events
	 */
	private fun readScreen(savedState: Bundle?): SingleLiveEvent<NS> {
		return savedState?.getParcelable<NS>(screenKey)?.let {
			val screen = SingleLiveEvent(it)
			if (savedState.getBoolean(screenHandledKey, false)) screen.value // mark as handled
			screen
		} ?: SingleLiveEvent(getInitialScreen())
	}

	/**
	 * Saves workflow navigation events
	 */
	private fun saveWorkflow(outState: Bundle, workflow: SingleLiveEvent<NW>?) {
		outState.putParcelable(workflowKey, workflow?.peek())
		outState.putBoolean(workflowHandledKey, workflow?.isHandled ?: true)
	}

	/**
	 * Restores workflow navigation events
	 */
	private fun readWorkflow(savedState: Bundle?): SingleLiveEvent<NW>? {
		return savedState?.getParcelable<NW>(workflowKey)?.let {
			val screen = SingleLiveEvent(it)
			if (savedState.getBoolean(workflowHandledKey, false)) screen.value // mark as handled
			screen
		}
	}

}